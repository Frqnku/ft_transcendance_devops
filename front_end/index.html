<!DOCTYPE html>

<html>
	<head>
    <meta charset="UTF-8">
    <title>My Web Page</title>
	<link rel="stylesheet" href="style.css">
	<script src="https://cdn.babylonjs.com/babylon.js"></script>
	<style>
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
    }

    #renderCanvas {
      width: 1000px;
      height: 500px;
      display: block;
    }
  </style>
	</head>

    <body>
        <div class="container">
            <nav>
                <div class="nav-links">
                    <button class="nav-link active" data-page="home">Home</button>
                    <button class="nav-link" data-page="pong">Pong</button>
                    <button class="nav-link" data-page="game2">Game 2</button>
                    <button class="nav-link" data-page="log_in">Log in</button>
                    <button class="nav-link" data-page="profile">Profile</button>
                </div>
            </nav>

            <div id="home" class="page active">
                <h1>Welcome to Our Website</h1>
                <div class="card">
                    <h2>New here?</h2>
                    <p>You can sign in here.</p>
                </div>
                <div class="card">
                    <h2>Already registered ?</h2>
                    <p>Log in here !</p>
                </div>
            </div>

            <div id="pong" class="page">
                <h1>Pong Game</h1>
				<canvas id="renderCanvas" touch-action="none"></canvas>
           </div>

            <div id="game2" class="page">
                <h1>Game 2</h1>
            </div>

            <div id="log_in" class="page">
                <h1>Log here</h1>
                <div class="card">
                    <form id="loginForm">
                        <div class="form-group">
                            <label for="email">Email:</label>
                            <input type="email" id="email" name="email" required>
                        </div>
                        <div class="form-group">
                            <label for="password">Password:</label>
                            <input type="password" id="password" name="password" required>
                        </div>
                        <button type="submit" class="btn">Login</button>
                    </form>
                </div>
            </div>

     
			<div id="data" class="page">
				<h1>API Data Example</h1>
				<div class="card">
					<h2>Random User Data</h2>
					<button id="loadData" class="btn">Load Random Users</button>
					<div id="dataContainer"></div>
				</div>
			</div>

			<div id="profile" class="page">
                <h1>Username</h1>
                <div class="card">
                    <div class="form-group">
                        <label for="email">Email:</label>
                        <input type="email" id="profile_email" name="email" required>
                    </div>
                    <div class="form-group">
                        <label for="password">New Password:</label>
                        <input type="password" id="profile_password" name="password" required>
                    </div>
                    <button type="submit" class="btn">Update profile</button>
                </div>
            </div>

        </div>
	<script>

    window.addEventListener('DOMContentLoaded', () => {
      const canvas = document.getElementById('renderCanvas');

      const setCanvasSize = () => {
        const dpr = Math.max(window.devicePixelRatio || 1, 1);
        canvas.width  = canvas.clientWidth  * dpr;
        canvas.height = canvas.clientHeight * dpr;
      };
      setCanvasSize();

      const engine = new BABYLON.Engine(canvas, true, {}, true);

      window.addEventListener('resize', () => {
        setCanvasSize();
        engine.resize();
      });

      const scene = new BABYLON.Scene(engine);

      const ball = BABYLON.MeshBuilder.CreateSphere('ball',
        { diameter: 0.5 }, scene);
      ball.position.set(0,0,0);

      const paddleLeft = BABYLON.MeshBuilder.CreateBox('paddleLeft',
        { width: 0.2, height: 1.5, depth: 0.2 }, scene);
      paddleLeft.position.set(-3,0,0);

      const paddleRight = BABYLON.MeshBuilder.CreateBox('paddleRight',
        { width: 0.2, height: 1.5, depth: 0.2 }, scene);
      paddleRight.position.set( 3,0,0);

      const camera = new BABYLON.ArcRotateCamera('cam',
        Math.PI/2, Math.PI/4, 4,
        BABYLON.Vector3.Zero(), scene);
      camera.attachControl(canvas, true);
	
	camera.wheelPrecision = 0.5;          // 6× plus rapide environ

	camera.wheelDeltaPercentage = 0.05;   // 5 % du radius à chaque cran

      new BABYLON.HemisphericLight('light',
    	new BABYLON.Vector3(0,1,0), scene);

      let ballVelocity = new BABYLON.Vector3(0.07, 0, 0);
      const inputMap = {};
      scene.actionManager = new BABYLON.ActionManager(scene);

      scene.actionManager.registerAction(
        new BABYLON.ExecuteCodeAction(
          BABYLON.ActionManager.OnKeyDownTrigger,
          evt => { inputMap[evt.sourceEvent.key] = true; }
        )
      );
      scene.actionManager.registerAction(
        new BABYLON.ExecuteCodeAction(
          BABYLON.ActionManager.OnKeyUpTrigger,
          evt => { inputMap[evt.sourceEvent.key] = false; }
        )
      );


	    function bounceWithAngle(paddle) {
			// Hauteur semi-active de la raquette
			const halfHeight = paddle.scaling.y / 2 || 1; // si tu scalais avec `height`, adapte ici
			// Position relative entre le centre de la balle et de la raquette (entre -1 et 1)
			const relativeY = (ball.position.y - paddle.position.y) / halfHeight;
			// Angle max de déviation (ici 45°)
			const maxAngle = Math.PI / 4;
			// Angle de rebond
			const bounceAngle = relativeY * maxAngle;
			// Vitesse totale avant rebond
			const speed = Math.sqrt(ballVelocity.x**2 + ballVelocity.y**2);
			// Sens horizontal : si c’est la raquette de gauche, on repart à droite (+), sinon à gauche (-)
			const dir = paddle === paddleLeft ? +1 : -1;
			// Recalcul des composantes
			ballVelocity.x = dir * Math.cos(bounceAngle) * speed;
			ballVelocity.y =         Math.sin(bounceAngle) * speed;
		}

      engine.runRenderLoop(() => {
        ball.position.addInPlace(ballVelocity);

        if (ball.position.y > 2 || ball.position.y < -2) {
          ballVelocity.y *= -1;
        }

        if (ball.intersectsMesh(paddleLeft, false) && ballVelocity.x < 0) {
          bounceWithAngle(paddleLeft);
        }

        if (ball.intersectsMesh(paddleRight, false) && ballVelocity.x > 0) {
          bounceWithAngle(paddleRight);
        }

        if (ball.position.x > 3 || ball.position.x < -3) {
		  if (ball.position.x > 3) {
          	ball.position = BABYLON.Vector3.Zero();
		  	ballVelocity = new BABYLON.Vector3(0.07, 0, 0);
		  }
		  else {
          	ball.position = BABYLON.Vector3.Zero();
		  	ballVelocity = new BABYLON.Vector3(-0.07, 0, 0);
		  }

        }

        // contrôle paddles
        if (inputMap['w'])      paddleLeft.position.y  += 0.1;
        if (inputMap['s'])      paddleLeft.position.y  -= 0.1;
        if (inputMap['o'])      paddleRight.position.y += 0.1;
        if (inputMap['l'])      paddleRight.position.y -= 0.1;

        scene.render();
      });
    });
  </script>
        <script src="script.js"></script>
    </body>

</html>
